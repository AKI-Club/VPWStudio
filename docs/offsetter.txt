notes on Zoinkity's VPW2 offsetter
==================================

--------------------------------------------------------------------------------
def offset(rom, index, data, force_raw=False, compress=-1):

"""This only changes offsets to files in the filetable!
Offsets the filetable values starting at index by difference.
Also alters the hardcoded pointers to the soundtable.

Set force_raw to True to retain the compression flag despite not doing compression.
This is used to insert 'raw', possibly pre-compressed files."""

# If compress = -1, this will select the smaller of the two filesizes.
# 1 and 0 force compressed or uncompressed, respectively.

    from array import array

    if isinstance(rom, bytes):
        rom = bytearray(rom)

	# (freem) get the filetable location from the code.
    h = int.from_bytes(rom[0x48DA:0x48DC], byteorder='big') << 16
    l = int.from_bytes(rom[0x48DE:0x48E0], byteorder='big', signed=True)
    filetable = h + l

	# (freem) get filetable
    tbl = array("L", rom[filetable:filetable+0xCC8C])
    tbl.byteswap()

    s = tbl[index] & (~1)
    e = tbl[index+1] & (~1)

    # True if compressed, so compress file before insertion.
    if (tbl[index] & 1) and not force_raw:
        org = len(data).to_bytes(4, 'big')
        data = b''.join((org, LZSS.encode(data, fill=0)))

    # Force output data HW aligned.
    if len(data)&1:
        data = b''.join((data, b'\x00'))

    difference = len(data) - (e - s)

    for i in range(index+1, len(tbl)):
        tbl[i] += difference

    tbl.byteswap()
    rom[filetable:filetable+0xCC8C] = tbl.tobytes()

    # Slide in the file after updating the offsets.
    rom[0x152DF0+s:0x152DF0+e] = data

    def addr2hws(a1, a2):
        h = int.from_bytes(rom[a1:a1+2], byteorder='big') << 16
        v = h + int.from_bytes(rom[a2:a2+2], byteorder='big', signed=True)
        v += difference
        h = (v>>16)
        if v & 0x8000:
            h += 1
        l = v & 0xFFFF
        rom[a1:a1+2] = h.to_bytes(2, byteorder='big')
        rom[a2:a2+2] = l.to_bytes(2, byteorder='big')

    addr2hws(0x48DA, 0x48DE)
    # The audio file offsets.
##    difference += 15
##    a = difference & 15
##    difference &= (~15)
    addr2hws(0x432A, 0x432E)
    addr2hws(0x4336, 0x433A)
    addr2hws(0x4366, 0x436A)
    addr2hws(0x436E, 0x4372)
    addr2hws(0x439A, 0x439E)
    addr2hws(0x43A2, 0x43A6)
    addr2hws(0x43CE, 0x43D2)
    addr2hws(0x43D6, 0x43DA)
    addr2hws(0x4402, 0x4406)
    addr2hws(0x440A, 0x440E)
    addr2hws(0x447A, 0x447E)
    addr2hws(0x44DE, 0x44E6)
    addr2hws(0x4512, 0x451A)
    addr2hws(0x17312,0x17316)
    addr2hws(0x1731A,0x1731E)
    addr2hws(0x1732E,0x17332)
    addr2hws(0x17336,0x1733A)
    addr2hws(0x173AE,0x173B2)
    addr2hws(0x173B6,0x173BA)
    addr2hws(0x173CA,0x173CE)
    addr2hws(0x173D2,0x173D6)
    addr2hws(0x17466,0x1746E)
    addr2hws(0x174AE,0x174B6)
    addr2hws(0x17772,0x17776)
    addr2hws(0x1777A,0x1777E)
    addr2hws(0x177A6,0x177AA)
    addr2hws(0x177AE,0x177B2)
    addr2hws(0x177EE,0x177F6)
    addr2hws(0x179FA,0x179FE)
    addr2hws(0x17A02,0x17A06)
    addr2hws(0x17A22,0x17A26)
    addr2hws(0x17A2A,0x17A2E)
    addr2hws(0x17A46,0x17A4A)
    addr2hws(0x17A4E,0x17A52)
    addr2hws(0x17A6A,0x17A6E)
    addr2hws(0x17A72,0x17A76)
    addr2hws(0x17B7A,0x17B82)
    addr2hws(0x17B46,0x17B4E)

##    h = int.from_bytes(rom[0x4336:0x4338], byteorder='big') << 16
##    l = int.from_bytes(rom[0x433A:0x433C], byteorder='big', signed=True)
##    filetable = h + l
##    rom.insert(filetable-a, bytes(a))

    return rom

--------------------------------------------------------------------------------
class LZSS:
    @staticmethod
    def encode(data, ring=4096, limit=18, threshold=2, idx=4078, fill=b' ', byteorder='little'):
        """
        A fairly straight port of Haruhiko Okumura's LZSS compressor from C.
        Nothing really clever, and not very pythonic.  (I'm not that good at this honestly.)
        idx is typically ring - limit.
        """
        output = bytearray()
        if not data: return output

        from itertools import repeat
        from array import array

        # Initialize the ring buffer with a common fill value.
        if isinstance(fill, (bytes, bytearray)):
            fill = fill[0]

        rng = bytearray(repeat(fill, ring + limit))
        matchlen, matchpos, nil = 0, 0, ring

        # Initialize the trees.
        lson= array('i', repeat(0, ring + 1))
        rson= array('i', repeat(0, ring + 1))
        rson.extend(repeat(nil, 256))
        dad = array('i', repeat(nil, ring + 1))

        def InsertNode(v):
            """Inserts string into trees and returns
            longest match position and length as a tuple.
            If match length equals the limit, it replaces the old node.
            By embedding this function it can use the trees and ring globally."""
            cmp, ml, mp = 1, 0, matchpos
            key = rng[v:]
            pos = ring + 1 + key[0]
            rson[v] = nil
            lson[v] = nil
            while True:
                if cmp>=0:
                    if rson[pos] != nil:
                        pos = rson[pos]
                    else:
                        rson[pos] = v
                        dad[v] = pos
                        return (ml, mp)
                else:
                    if lson[pos] != nil:
                        pos = lson[pos]
                    else:
                        lson[pos] = v
                        dad[v] = pos
                        return (ml, mp)
                for i in range(1, limit+1):
                    cmp = key[i] - rng[pos + i]
                    if cmp:
                        break
                if i > ml:
                    mp, ml = pos, i
                    if ml >= limit: break
            dad[v] = dad[pos]
            lson[v]=lson[pos]
            rson[v]=rson[pos]
            dad[lson[pos]] = v
            dad[rson[pos]] = v
            if rson[dad[pos]] == pos:
                rson[dad[pos]] = v
            else:
                lson[dad[pos]] = v
            dad[pos] = nil
            return (ml, mp)

        def DeleteNode(pos):
            if dad[pos] == nil: return
            # If it's in the tree, delete it.
            q = lson[pos]
            if lson[pos] == nil:
                q = rson[pos]
            elif rson[pos] != nil:
                if rson[q] != nil:
                    while True:
                        q = rson[q]
                        if rson[q] == nil: break
                    rson[dad[q]] = lson[q]
                    dad[lson[q]] = dad[q]
                    lson[q] = lson[pos]
                    dad[lson[pos]] = q
                rson[q] = rson[pos]
                dad[rson[pos]] = q
            dad[q] = dad[pos]
            if rson[dad[pos]] == pos:
                rson[dad[pos]] = q
            else:
                lson[dad[pos]] = q
            dad[pos] = nil

        # Unset flags on copies; send when less than 256.
        mask = 0xFF00
        codebuf = bytearray()
        s = 0

        # Read limit bytes into the ring at idx.
        p = min(limit, len(data)-1)
        rng[idx:idx+p] = data[0:p]
        cur = p
        for i in range(1, limit+1):
            matchlen, matchpos = InsertNode(idx - i)
        matchlen, matchpos = InsertNode(idx)

        # Now you're initialized, so do the rest of the file.
        while True:
            mask>>=1
            matchlen = min(matchlen, p)
            if matchlen <= threshold:
                matchlen = 1
                codebuf.append(rng[idx])
            else:
                mask ^= 128
                a = (matchpos>>4) & 0xF0
                a |= (matchlen - threshold - 1)
                b = matchpos&0xFF
                if byteorder == 'little':
                    codebuf.extend((b,a))
                else:
                    codebuf.extend((a,b))
            # Flush when the mask is full.
            if mask < 256:
                output.append(mask)
                output.extend(codebuf)
                codebuf = bytearray()
                mask = 0xFF00
            prevmatchlen = matchlen
            j = min(prevmatchlen, len(data)-cur)
            for i in range(j):
                DeleteNode(s)
                rng[s] = data[cur]
                if s < (limit - 1):
                    rng[s + ring] = data[cur]
                cur+=1
                # Correct the ring position via modulo ring
                s+=1
                s&= ring-1
                idx+=1
                idx&= ring-1
                matchlen, matchpos = InsertNode(idx)
            # Flush the rest of the buffer if necessary.
            for i in range(j, prevmatchlen):
                DeleteNode(s)
                s+=1
                s&= ring-1
                idx+=1
                idx&= ring-1
                p-=1
                if p:
                    matchlen, matchpos = InsertNode(idx)
            # Loop until source empty.
            if not p:
                break
        # Flush remaining output; mask the lead bit off the mask.
        if codebuf:
            ## mask &= ~(1<<mask.bit_length()-1)   # bottom to top bitorder.
            l = mask.bit_length() - 8
            mask &= 0xFF
            output.append(mask>>l)
            output.extend(codebuf)
        return output


