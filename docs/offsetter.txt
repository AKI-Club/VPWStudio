notes on Zoinkity's VPW2 offsetter
==================================

--------------------------------------------------------------------------------
def offset(rom, index, data, force_raw=False, compress=-1):

"""This only changes offsets to files in the filetable!
Offsets the filetable values starting at index by difference.
Also alters the hardcoded pointers to the soundtable.

Set force_raw to True to retain the compression flag despite not doing compression.
This is used to insert 'raw', possibly pre-compressed files."""

# If compress = -1, this will select the smaller of the two filesizes.
# 1 and 0 force compressed or uncompressed, respectively.


--------------------------------------------------------------------------------
class LZSS:
    @staticmethod
    def encode(data, ring=4096, limit=18, threshold=2, idx=4078, fill=b' ', byteorder='little'):
        """
        A fairly straight port of Haruhiko Okumura's LZSS compressor from C.
        Nothing really clever, and not very pythonic.  (I'm not that good at this honestly.)
        idx is typically ring - limit.
        """
        output = bytearray()
        if not data: return output

        from itertools import repeat
        from array import array

        # Initialize the ring buffer with a common fill value.
        if isinstance(fill, (bytes, bytearray)):
            fill = fill[0]

        rng = bytearray(repeat(fill, ring + limit))
        matchlen, matchpos, nil = 0, 0, ring

        # Initialize the trees.
        lson= array('i', repeat(0, ring + 1))
        rson= array('i', repeat(0, ring + 1))
        rson.extend(repeat(nil, 256))
        dad = array('i', repeat(nil, ring + 1))

        def InsertNode(v):
            """Inserts string into trees and returns
            longest match position and length as a tuple.
            If match length equals the limit, it replaces the old node.
            By embedding this function it can use the trees and ring globally."""
            cmp, ml, mp = 1, 0, matchpos
            key = rng[v:]
            pos = ring + 1 + key[0]
            rson[v] = nil
            lson[v] = nil
            while True:
                if cmp>=0:
                    if rson[pos] != nil:
                        pos = rson[pos]
                    else:
                        rson[pos] = v
                        dad[v] = pos
                        return (ml, mp)
                else:
                    if lson[pos] != nil:
                        pos = lson[pos]
                    else:
                        lson[pos] = v
                        dad[v] = pos
                        return (ml, mp)
                for i in range(1, limit+1):
                    cmp = key[i] - rng[pos + i]
                    if cmp:
                        break
                if i > ml:
                    mp, ml = pos, i
                    if ml >= limit: break
            dad[v] = dad[pos]
            lson[v]=lson[pos]
            rson[v]=rson[pos]
            dad[lson[pos]] = v
            dad[rson[pos]] = v
            if rson[dad[pos]] == pos:
                rson[dad[pos]] = v
            else:
                lson[dad[pos]] = v
            dad[pos] = nil
            return (ml, mp)

        def DeleteNode(pos):
            if dad[pos] == nil: return
            # If it's in the tree, delete it.
            q = lson[pos]
            if lson[pos] == nil:
                q = rson[pos]
            elif rson[pos] != nil:
                if rson[q] != nil:
                    while True:
                        q = rson[q]
                        if rson[q] == nil: break
                    rson[dad[q]] = lson[q]
                    dad[lson[q]] = dad[q]
                    lson[q] = lson[pos]
                    dad[lson[pos]] = q
                rson[q] = rson[pos]
                dad[rson[pos]] = q
            dad[q] = dad[pos]
            if rson[dad[pos]] == pos:
                rson[dad[pos]] = q
            else:
                lson[dad[pos]] = q
            dad[pos] = nil

        # Unset flags on copies; send when less than 256.
        mask = 0xFF00
        codebuf = bytearray()
        s = 0

        # Read limit bytes into the ring at idx.
        p = min(limit, len(data)-1)
        rng[idx:idx+p] = data[0:p]
        cur = p
        for i in range(1, limit+1):
            matchlen, matchpos = InsertNode(idx - i)
        matchlen, matchpos = InsertNode(idx)

        # Now you're initialized, so do the rest of the file.
        while True:
            mask>>=1
            matchlen = min(matchlen, p)
            if matchlen <= threshold:
                matchlen = 1
                codebuf.append(rng[idx])
            else:
                mask ^= 128
                a = (matchpos>>4) & 0xF0
                a |= (matchlen - threshold - 1)
                b = matchpos&0xFF
                if byteorder == 'little':
                    codebuf.extend((b,a))
                else:
                    codebuf.extend((a,b))
            # Flush when the mask is full.
            if mask < 256:
                output.append(mask)
                output.extend(codebuf)
                codebuf = bytearray()
                mask = 0xFF00
            prevmatchlen = matchlen
            j = min(prevmatchlen, len(data)-cur)
            for i in range(j):
                DeleteNode(s)
                rng[s] = data[cur]
                if s < (limit - 1):
                    rng[s + ring] = data[cur]
                cur+=1
                # Correct the ring position via modulo ring
                s+=1
                s&= ring-1
                idx+=1
                idx&= ring-1
                matchlen, matchpos = InsertNode(idx)
            # Flush the rest of the buffer if necessary.
            for i in range(j, prevmatchlen):
                DeleteNode(s)
                s+=1
                s&= ring-1
                idx+=1
                idx&= ring-1
                p-=1
                if p:
                    matchlen, matchpos = InsertNode(idx)
            # Loop until source empty.
            if not p:
                break
        # Flush remaining output; mask the lead bit off the mask.
        if codebuf:
            ## mask &= ~(1<<mask.bit_length()-1)   # bottom to top bitorder.
            l = mask.bit_length() - 8
            mask &= 0xFF
            output.append(mask>>l)
            output.extend(codebuf)
        return output


